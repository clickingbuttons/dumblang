// Variables allow you to alias [values](./01-values.du) to operate on.
// Since computers do not quickly process arbitrary precision numbers it's a
// necessary evil to specify a range your numeric types can hold.

globalStatic = 42
test "global static" {
	assert globalStatic == 42
}

test "integer variable" {
	my_integer: [-255, 255] = 0
	assert my_integer == 0
	my_integer = -255
	assert my_integer == -255
	my_integer = 255
	assert my_integer == 255
	// my_integer = 256 // Fails at compile time.
	// my_integer = bad_user_input // Fails at runtime with the "safe" flag.
}

// Supported shorthands:
// - Signed/unsigned integer: iX / uX
// - IEEE 754-2008 binary types: f16, f32, f64, f128, f256
// - IEEE 754-2008 decimal types???
// - minifloats??
test "integer variable shorthand" assert i8 == [-255, 255]

// Large ranges that are unsupported in hardware will be emulated in software.
test "large integer type" {
	my_integer: i256 = 123_456_789_123_456_789
	assert my_integer == 123_456_789_123_456_789
}

// You may operate on numbers:
// operator | precedence | associativity | function
// ---------|-----------=|---------------|--------------------
// ()       |         12 | ltr           | grouping
// -        |         11 | rtl           | unary negation
// ~        |         11 | rtl           | bitwise not
// **       |         10 | ltr           | exponentiation
// *        |          9 | ltr           | multiplication
// /        |          9 | ltr           | division
// %        |          9 | ltr           | remainder
// /%       |          9 | ltr           | divmod
// +        |          8 | ltr           | addition
// -        |          8 | ltr           | subtraction
// >>       |          7 | ltr           | bitwise right shift
// <<       |          7 | ltr           | bitwise left shift
// ==       |          6 | ltr           | equality comparison
// !=       |          6 | ltr           | non-equality comparison
// &        |          5 | ltr           | bitwise and
// ^        |          4 | ltr           | bitwise xor
// |        |          3 | ltr           | bitwise or
// &&       |          2 | ltr           | logical and
// ||       |          1 | ltr           | logical or
// =        |          0 | rtl           | assignment
// += -=    |          0 | rtl           | ...by sum/difference
// *= /=    |          0 | rtl           | ...by multiplication/division
// %= /%=   |          0 | rtl           | ...by remainder/division+remainder
// <<= >>=  |          0 | rtl           | ...by left/right bitshift
// &= ^= |= |          0 | rtl           | ...by logical and/xor/or

// TODO: add all operators
//  - saturating and wrapping addition, subtraction, and multiplication
//  - & !
//  - error set merge
//  - error catch
// TODO: decide on null coalescing operator `??` and `?.`

test "operator precedence" {
	// TODO: find good example set or write own
}

// Ranges are inferred based on their assignment to be the smallest possible.
// Be careful omitting ranges: you can quickly end up with large precision!
test "integer range inference" {
	my_integer: i8 = i8::max
	my_other_integer = my_integer * my_integer
	assert my_other_integer::type == i16
}

// Shadowing is allowed in new scopes.
test "shadowing" {
	my_integer: i8 = 0
	assert my_integer == 0

	// Reassignment
	my_integer = 1
	assert my_integer == i8(1)

	// Compile error.
	// my_integer: i16 = 1

	{
		// Shadowed.
		my_integer: u16 = 3
		assert my_integer == u16(3)
	}

	// Shadowed, refers to the function parameter
	square = (my_integer) => my_integer * my_integer
	assert square(2) == 4
}

// Arbitrary precision hardware doesn't exist. For this reason you may add
// range constraints to types for compiler optimization. They may also help
// you solve equations.
test "value constraints" {
	my_bool: 0..1 = 0
	my_bool = 1
	// my_bool = 2 // compile error

	// If you omit the type, the compiler will infer the tighest constraint.
	my_integer = 32 // 32..32
	my_integer *= my_integer // 1024..1024
}

// Optionals may take on a "null" value.
test "optionals" {
	a: ?u8 = null
	assert a == null
	a = 32
	assert a.? == 32
}

// Arrays may be destructured.
test "destructuring" {
	a, b, c, d = i32[1, 2, 3, 4]
	assert a == i32(1) && b == i32(2) && c == i32(3) && d == i32(4)
}

// test "thread local storage" {
// 	threadlocal x: i32 = 1234
// 
// 	test_tls() {
// 		assert(x == 1234)
// 		x += 1
// 		assert(x == 1235)
// 	}
// 	thread1 = std.Thread.spawn({}, test_tls)!
// 	thread2 = std.Thread.spawn({}, test_tls)!
// 	test_tls()
// 	thread1.join()
// 	thread2.join()
// }
